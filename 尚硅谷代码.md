```java
package com.qlu;

/**
 * @author jiajinshuo
 * @create 2019-12-20 19:44
 * 用三元运算符获取三个数中最大的数
 */
public class Max {

    public static void main(String[] args) {

        int a = 12;
        int b = 78;
        int c = 6;
        
        int max1 = (a > b) ? a : b;
        int max2 = (max1 > c)? max1 : c ;
        System.out.println(max2);
    }
}

```

```java
package com.qlu;

/**
 * @author jiajinshuo
 * @create 2019-12-20 21:45
 * 如何获取一个随机数 [10,99)
 */
public class RandomTest {

    public static void main(String[] args) {
        //公式：[a,b]   (b -a +1) +a
       int num =  (int)(Math.random() * 90 + 10);
       System.out.println(num);
    }
}

```

```java
package com.qlu;


/**
 * @author jiajinshuo
 * @create 2019-12-20 22:09
 */
public class SwitchTest {
//对于学生成绩大于60分的输出“合格”，少于60分的输出“不合格” 用switch语句实现
    //当多个case语句相同可以考虑合并
    public static void main(String[] args) {

        int score = 78;
        switch (score / 10){

            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                System.out.println("不合格");
                break;
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
                System.out.println("合格");
                break;
                
            

        }
        /*//更优的解决方案：
        switch (score / 60){
            case 0:
                System.out.println("不合格");
                break;
            case 1:
                System.out.println("合格");
                break;
        }*/
        
    }


}

```

```java
package com.qlu;

import java.util.Scanner;

/**
 * @author jiajinshuo
 * @create 2019-12-20 22:48
 * 编写程序，从键盘上输入2019年的month和day，要求通过程序输出输入的日期为
 * 2019年的第几天
 */
public class SwitchTest2 {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        System.out.println("请输入月份");
        int month = sc.nextInt();
        System.out.println("请输入天");
        int day = sc.nextInt();

        int sumDays = 0;

        switch(month){

            case 12:sumDays += 30;
            case 11:sumDays += 31;
            case 10:sumDays += 30;
            case 9 :sumDays += 31;
            case 8 :sumDays += 31;
            case 7 :sumDays += 30;
            case 6 :sumDays += 31;
            case 5 :sumDays += 30;
            case 4 :sumDays += 31;
            case 3 :sumDays += 28;
            case 2 :sumDays += 31;
            case 1 :sumDays += day;
        }
        System.out.println("2019年的"+month+"月"+day+"日是这一年的第"+sumDays+"天");

    }
}

```

```java
package com.qlu;

import java.util.Scanner;

/**
 * @author jiajinshuo
 * @create 2019-12-21 11:51
 * 从键盘分别输入年、月、日，判断这一天是当年的第几天
 * 注:判断一年是否是闰年的标准:
 * 1)可以被4整除，但不可被100整除
 * 或
 * 2)可以被400整除
 */
public class SwitchTest3 {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        System.out.println("请输入年");
        int year = sc.nextInt();
        System.out.println("请输入月");
        int month = sc.nextInt();
        System.out.println("请输入天:");
        int day = sc.nextInt();
        


        int sumDays = 0;

        switch(month){

            case 12:sumDays += 30;
            case 11:sumDays += 31;
            case 10:sumDays += 30;
            case 9 :sumDays += 31;
            case 8 :sumDays += 31;
            case 7 :sumDays += 30;
            case 6 :sumDays += 31;
            case 5 :sumDays += 30;
            case 4 :sumDays += 31;
            case 3 :
                    if((year % 4 ==0 && year % 100 != 0) || year % 400 ==0){
                        sumDays+=29;
                    }else{
                        sumDays+=28;
                    }
            case 2 :sumDays += 31;
            case 1 :sumDays += day;
        }
        System.out.println(year+"年的"+month+"月"+day+"日是这一年的第"+sumDays+"天");

    }
}

```

#### 循环结构

循环结构的4个要素
①初始化条件
②循环条件 --->是boolean类型
③循环体
④迭代条件

##### for循环

```java
package com.qlu;

/**
 * @author jiajinshuo
 * @create 2019-12-21 12:38
 * 遍历100以内的偶数,每五行打印
 */
public class ForTest {

    public static void main(String[] args) {

        int count = 0;
        for(int i = 1;i<=100;i++){
            if(i % 2 == 0){
                System.out.print(i+"\t");
                count++;
                if(count % 5 ==0){
                    System.out.println();
                }

            }
        }
    }
}

```

```java
package com.qlu;

import java.util.Scanner;

/**
 * @author jiajinshuo
 * @create 2019-12-21 13:18
 * 题目:输入两个正整数m和n，求其最大公约数和最小公倍数。
 * 比如: 12和20的最大公约数是4，最小公倍数是60。
 * 说明: break关键 字的使用
 */
public class ForTest2 {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        System.out.println("请输入第一个正整数");
        int m = sc.nextInt();

        System.out.println("请输入第二个正整数");
        int n = sc.nextInt();
        //求最大公约数
        int min = (m <= n) ? m : n;

        for(int i = min;i>=1 ;i--){
            if(m % i == 0 && n % i == 0){
                System.out.println("最大公约数为:"+i);
                break;//一旦在循环中执行到break，就跳出循环。找到就结束
            }
        }

        //求最小公倍数
        //获取两个数最大的
        int max = (m >= n) ? m : n;
        for(int i = max ;i < m*n;i ++){
            if(i % m == 0 && i % n == 0){
                System.out.println("最小公倍数为:"+i);
                break;
            }
        }
    }
}

```

```java
package com.qlu;

import java.util.Scanner;

/**
 * @author jiajinshuo
 * @create 2019-12-21 13:43
 * 三位数水仙花数：
 * 153 = 1*1*1 + 5*5*5 + 3*3*3
 */
public class ForTest3 {
    //打印出三位数所有的水仙花数
    public static void main(String[] args) {

        for(int i = 100 ;i < 1000;i++){
            int a = i / 100;
            int b = i % 100 /10;
            int c = i % 10;
            if( i == a*a*a + b*b*b + c*c*c){
                System.out.println(i+"\t");
            }
        }
    }
}

```

##### while循环

```java
package com.qlu;

/**
 * @author jiajinshuo
 * @create 2019-12-21 14:01
 *遍历1-100的偶数
 *for循环和while循环可以互相转换
 */
public class WhileTest {

    public static void main(String[] args) {

        int i = 1;
        while(i < 100){
            if(i % 2 == 0){
                System.out.println(i+"\t");
            }
            i++;//这个条件不能放到if里面，因为有可能执行不到，丢了迭代条件会死循环
        }
        System.out.println(i)//101,和for循环不同，定义的变量i继续可以使用，for循环只能内部使用
    }
}

```

```java
package com.qlu;

import java.util.Scanner;

/**
 * @author jiajinshuo
 * @create 2019-12-21 14:24
 * 题目:
 * 从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，
 * 输入为0时结束程序。
 */
public class ForWhileTest {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int positiveNumber = 0;//记录正数的个数
        int negativeNumber = 0;//记录负数的个数

        while(true){

            int number = sc.nextInt();
            //判断number的正负
            if(number > 0){
                positiveNumber++;
            }else if(number < 0){
                negativeNumber++;
            }else{
                break;//一旦执行break跳出循环
            }
        }
        System.out.println("正数的个数为："+positiveNumber);
        System.out.println("负数的个数为："+negativeNumber);
    }
}

```

##### 嵌套循环

```java
package com.qlu;

/**
 * @author jiajinshuo
 * @create 2019-12-21 14:53
 * 内层循环结构遍历一遍，只相当于外层循环循环体执行了-次
 * 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次
 */
public class ForQianTao {

    public static void main(String[] args) {

        for(int i = 1;i< 5;i++){
            for(int j = 1;j< 6;j++){
                System.out.print("*");
            }
            System.out.println();
        }
    }
}

```

```java
package com.qlu;

public class ForQianTao {

    public static void main(String[] args) {
		//i控制行数，j控制列数
        for(int i = 1;i< 5;i++){
            //每一次i+j都等于5，j控制每一行的个数
            for(int j = 1;j<= (5-i);j++){
                System.out.print("*");
            }
            System.out.println();
        }
        ****
		***
		**
		*
    }
}

```

```java
package com.qlu;

/**
 * @author jiajinshuo
 * @create 2019-12-21 15:27
 * 打印1-100以内所有的质数，每五行输出
 * 质数：只能被1它本身整除的自然数
 * 最小的质数：2
 */
public class ZhiShuTest {

    public static void main(String[] args) {

        int count = 0;
        for(int i = 2;i<100;i++){
            int j = 2;
            while(i % j != 0){
                j++;
            }
            if(i == j){
                System.out.print(i+"\t");
                count++;
                if(count % 5 == 0){
                    System.out.println();
                }
            }
        }


    }
}

```

```java
package com.qlu;

/**
 * @author jiajinshuo
 * @create 2019-12-21 15:54
 * 方法二：
 * 输出1-100的质数
 */
public class ZhiShuTest2 {
    public static void main(String[] args) {

        boolean isFlag = true;
        for(int i = 2;i<=100;i++){
            for(int j = 2;j<Math.sqrt(i);j++){//优化二：极限为两个乘数相等
                if(i % j == 0){//能被除断则不是质数
                    isFlag = false;
                    break;//优化一：能除断就判断是偶数了，就不要再除了
                }
            }
            if(isFlag == true){
                System.out.println(i+"\t");
            }
            //重置isFlag。因为前面可能存在偶数导致isFlag为false
            isFlag = true;
        }
    }
}

```



```java
package com.qlu;

import java.awt.*;

/**
 * @author jiajinshuo
 * @create 2019-12-21 17:29
 * 输出质数另一种方法
 */
public class ZhiShuTest3 {

    public static void main(String[] args) {

        label:for(int i = 2;i<=100;i++){
            for(int j =2;j<=Math.sqrt(i);j++){
                if(i % j == 0){
                    continue label;//不用“进屋穿马甲”，不符合规定，立马消失，换另一个i
                }
            }
            System.out.println(i+" ");
        }


    }
}

```



```
package com.qlu;

import java.awt.*;

/**
 * @author jiajinshuo
 * @create 2019-12-21 16:28
 * breaK和continue关键字的使用
 * continue：结束当次循环
 * 二者后面都不能有执行语句
 */
public class BreakContinueTest {

    public static void main(String[] args) {

        for(int i = 1;i<=10;i++){
            if(i % 4 == 0){
               // break; 123  默认跳出包裹关键字最近的循环
                continue;//1	2	3	5	6	7	9	10
            }
            System.out.print(i+"\t");
        }
        System.out.println();

        label:for(int i = 1;i<=4;i++){
            for(int j = 1;j <= 10;j++){
                if(j % 4 == 0){
                   // break ;
                    //continue ;
                   // break label;//结束指定标识的一层循环结构 1 2 3
                    continue label;//1	2	3	1	2	3	1	2	3	1	2	3	
                }
                System.out.print(j+"\t");
            }
        }

    }
}

```



#### 数组

```java
package com.array;

/**
 * @author jiajinshuo
 * @create 2019-12-26 18:00
 * 数组的初始化
 */
public class ArrayIni {
    public static void main(String[] args) {

        String[] str = new String[5];
        System.out.println(str[0]); //null
        System.out.println(str);//[Ljava.lang.String;@1b6d3586
        int[] ints = new int[5];
        System.out.println(ints[0]);//0
        System.out.println(ints);//[I@4554617c

        char[] ch = new char[]{'a','b'};
        //api中是对char型数组的遍历
        System.out.println(ch);//ab


    }
}

```



```java
package com.array;

import java.util.Scanner;

/**
 * @author jiajinshuo
 * @create 2019-12-21 19:47
 * 2.从键盘读入学生成绩，找出最高分，
 * 并输出学生成绩等级。
 * 成绩>=最高分-10 等级为'A'
 * 成绩>=最高分-20 等级为'B'’
 * 成绩>=最高分-30 等级为'C'
 * 其余等级为'D'
 */
public class ArrayDemo1 {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        System.out.println("请输入学生人数");
        int num = sc.nextInt();

        int[] scores = new int[num];
        System.out.println("请输入"+num+"个学生成绩");
        int maxScore = 0;
        for(int i = 0;i<scores.length;i++){
            scores[i] = sc.nextInt();
            //获得数组中最大值
            if(maxScore <= scores[i]){
                maxScore = scores[i];
            }

        }

        char level;
        for(int i = 0;i < scores.length;i++){
            if(maxScore - scores[i] <= 10){
                level = 'A';
            }else if(maxScore - scores[i] <= 20){
                level = 'B';
            }else if(maxScore - scores[i] <= 30){
                level = 'C';
            }else {
                level = 'D';
            }
            System.out.println("student"+i+"score is "+scores[i]+",grade is"+level);

        }
    }
}

```

```java
package com.array;

/**
 * @author jiajinshuo
 * @create 2019-12-21 20:38
 * //遍历二维数组
 *二维数组两层for循环。三维数组三层for循环
 */
public class ArrayBianLi {

    public static void main(String[] args) {

        int[][] arr = {{1,2,3,4},{9,8},{5,4}};
        for(int i = 0;i<arr.length;i++){
            for(int j = 0;j<arr[i].length;j++){
                System.out.print(arr[i][j]+" ");
            }
            System.out.println();
        }
    }
}

```

```java
package com.array;

/**
 * @author jiajinshuo
 * @create 2019-12-22 13:16
 * 打印10行杨辉三角
 */
public class Triangle {

    public static void main(String[] args) {

        //声明并初始化数组
        int[][] yangHui = new int[10][];
        //给数组的元素赋值
        for(int i = 0;i<yangHui.length;i++){
            yangHui[i] = new int[i+1];
            yangHui[i][0] = yangHui[i][i] = 1;
           // if(i>1){
                for(int j = 1;j<yangHui[i].length-1;j++){
                    yangHui[i][j] = yangHui[i-1][j]+yangHui[i-1][j-1];
                }
           // }

        }
        for(int i = 0;i<yangHui.length;i++){
            for(int j = 0;j<yangHui[i].length;j++){
                System.out.print(yangHui[i][j]+" ");
            }
            System.out.println();
        }

    }
}

```

```java
package com.array;

/**
 * @author jiajinshuo
 * @create 2019-12-22 15:39
 * 杨辉三角方法二
 */
public class Triangle2 {

    public static void main(String agrs[]) {
        int[][] a = new int[10][10];//如果后面的10不写，会空指针异常
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j <= i; j++) {
                if (i == j || j == 0) {
                    a[i][j] = 1;
                } else {
//a[2][1] = a[1][0]+a[1][1]
//2 = 1+1
                    a[i][j] = a[i - 1][j - 1] + a[i - 1][j];
                }
                System.out.print(a[i][j] + " ");
            }
            System.out.println("");
        }
    }

}

```

```java
package com.array;

/**
 * @author jiajinshuo
 * @create 2019-12-22 16:06
 * 算法的考查:求数值型数组中元素的最大值、最小值、平均数、总和等
 * 定义一个int型的一维数组，包含10个元素，分别赋一 些随机整数，
 * 然后求出所有元素的最大值，最小值，和值，平均值，并输出出来。
 * 要求:所有随机数都是两位数。
 */
public class ArrayCal {
    public static void main(String[] args) {

        int[] arr = new int[10];
        for(int i = 0;i<arr.length;i++){
            arr[i] = (int)(Math.random()*(99-10+1)+10);
        }

        for(int i:arr){
            System.out.print(i+"  ");
        }
        System.out.println();
        //求元素的最大值
        int maxValue = arr[0];//如果全是负数初始值就不能为0
        for(int i = 1;i<arr.length;i++){
            if(arr[i] > maxValue){
                maxValue = arr[i];
            }
        }
        System.out.println("最大值为"+maxValue);
        System.out.println();
        //求最小值
        int minValue = arr[0];
        for(int i = 1;i<arr.length;i++){
            if(arr[i] < minValue){
                minValue = arr[i];
            }
        }
        System.out.println("最小值为"+minValue);
        //求元素的总和
        int sum = 0;
        for(int i = 1;i<arr.length;i++){
            sum+=arr[i];
        }
        System.out.println("总和为"+sum+"平均数为"+(double)sum/arr.length);

    }
}

```

```java
package com.array;

import java.util.Arrays;

/**
 * @author jiajinshuo
 * @create 2019-12-25 13:02
 * Arrays工具类的使用
 */
public class ArraysTest {
    public static void main(String[] args) {

        int[] arr1 = {1,2,3,4};
        int[] arr2 = {1,3,2,4};
        System.out.println(Arrays.equals(arr1,arr2));//判断两个数组是否相等
        System.out.println(Arrays.toString(arr2));//输出数组的信息。直接遍历

        Arrays.fill(arr1,10);//将指定的值填充到数组之中，全部替换。[10, 10, 10, 10]
        System.out.println(Arrays.toString(arr1));

        int[] arr3 = {-89,-8,5,45,54,66,88,99,789};
        int index = Arrays.binarySearch(arr3,99);//二分查找法
        if(index >= 0){
            System.out.println("目标的索引"+index);
        }else {
            System.out.println("未找到");
        }
    }



}

```



#### 算法

```java
package com.array;

/**
 * @author jiajinshuo
 * @create 2019-12-22 17:29
 * 算法的考查:数组的复制、反转、查找(线性查找、二分法查找)
 */
public class SuanFa {
    public static void main(String[] args) {

        String[] arr1 = {"aa","bb","cc","dd"};
        String[] arr2 = new String[arr1.length];

        for(int i = 0;i<arr2.length;i++){
            arr2[i] = arr1[i];
        }
        //数组的反转
        /*for(int i = 0;i<arr1.length/2;i++){
            String temp = arr1[arr1.length - i -1];
            arr1[arr1.length - i - 1] = arr1[i];
            arr1[i] = temp;
        }*/
        for(String i:arr1){
            System.out.print(i+"  ");
        }
        //查找（搜索）线性查找
        String dest = "aa";
        boolean isFlag = true;
        for(int i = 0;i<arr1.length;i++){
            if(dest.equals(arr1[i])){
                System.out.println("目标在"+i);
                isFlag = false;
                break;
            }
        }
        if(isFlag){
            System.out.println("没有找到");
        }
        //二分法查找
        //所要查找的数组必须有序
        int[] arr3 = {-5,-4,5,6,58,69,96,99};
        int dest1 = 5;
        int head = 0;//初始的索引
        int end = arr3.length - 1;//初始的末索引
        boolean isFlag1 = true;

        while (head <= end){

            int middle = (head + end) /2;
            if(dest1 == arr3[middle]){
                System.out.println("二分查找法找到了指定的元素在"+middle);
                isFlag1 = false;
                break;
            }else if(arr3[middle] > dest1){
                end = middle - 1;
            }else{//arr3[middle < dest1
                head = middle + 1;
            }

        }
        if(isFlag1){
            System.out.println("没有找到");
        }

    }
}

```

```java
package com.array;

/**
 * @author jiajinshuo
 * @create 2019-12-25 12:00
 * 冒泡排序
 */
public class BubbleSort {

    public static void main(String[] args) {

        int[] arr = {23,6,5,-4,56,25,89,65,55};
        for(int i = 0;i<arr.length - 1;i++){
            for(int j = 0;j<arr.length - 1 - i;j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }

            }
        }
        for(int i = 0;i< arr.length;i++){
            System.out.print(arr[i]+"  ");
        }
        /*for(int i : arr){
            System.out.print(arr[i]+"  ");//使用foreach 会数组越界异常，for就不会
        }*/
    }
}

```

```java
package com.array;

import java.util.Arrays;

/**
 * @author jiajinshuo
 * @create 2019-12-25 12:11
 * 冒泡排序
 */
public class BubbleSort2 {

    public void bubbleSort(int[] arr,Integer n){
        if(n<=1){//如果只有一个元素就不用排序了
            return;
        }

        for(int i = 0;i<arr.length - 1;i++){
            boolean isFlag = true;
            for(int j = 0;j< arr.length - 1 -i;j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j + 1] = temp;
                    isFlag = false;
                }
            }
            if(isFlag){
                break;//没有数据交换，说明数组已经有序，退出排序
            }

        }
    }

    public static void main(String[] args) {
        int[] arr = {56,-8,4,5,4,56,2,-7,89,88};
        BubbleSort2 bs = new BubbleSort2();
        bs.bubbleSort(arr,arr.length);
        System.out.println(Arrays.toString(arr));
    }
}

```

插

#### 面向对象

```java
package com.oop;

/**
 * @author jiajinshuo
 * @create 2019-12-25 19:01
 * 4.对象数组题目:
 * 定义类Student，包含三个属性:学号number(int)， 年级state(int)，成绩
 * score(int)。创建20个学生对象， 学号为1到20，年级和成绩都由随机数确定。
 * 问题一:打印出3年级(state值为3)的学生信息。
 * 问题二:使用冒泡排序按学生成绩排序，并遍历所有学生信息
 * 提示:
 * 1)生成随机数: Math.random()， 返回值类型double;
 * 2)四舍五入取整: Math.round(double d)，返回值类型long。
 */
public class Student {

    int number;//学号
    int state;//年级
    int score;//成绩

    //显示学生的信息
    public String info(){
        return "学号："+number+"，年级："+state+",成绩"+score;
    }

}
class StudentTest{
    public static void main(String[] args) {
        //创建Student类型的数组
        Student[] stus = new Student[20];
        //给数组元素赋值
        for(int i = 0;i<stus.length;i++){
            stus[i] = new Student();
            //给student对象的属性赋值
            stus[i].number = i +1;
            //年级[1,6]
            stus[i].state = (int)(Math.random()*(6-1+1)+1);
            //成绩[0,100]
            stus[i].score = (int)(Math.random()*(100-0+1)+0);
        }
        //遍历学生数组
        for(int i = 0;i<stus.length;i++){
            //直接打印会显示地址值。必须得调用
            System.out.println(stus[i].number+","+stus[i].state+","+stus[i].score);
        }
        //打印出三年级state=3学生的信息
        for(int i = 0;i<stus.length;i++){
            if(stus[i].state == 3){
                System.out.println( stus[i].info());
            }
        }
        System.out.println("接下来使用冒泡排序按学生成绩排序，并遍历所有信息");
        for(int i = 0;i<stus.length - 1;i++){
            for(int j = 0;j<stus.length - 1- i;j++){
                if(stus[j].score > stus[j+1].score){
                    Student temp = stus[j]; //交换的不是学生成绩，是学生
                    stus[j] = stus[j+1];
                    stus[j+1]= temp;
                }
            }
        }
        //遍历
        for(int i = 0;i<stus.length;i++){
            System.out.println(stus[i].info());
        }

    }
}
```

```java

package com.oopplus;

/**
 * @author jiajinshuo
 * @create 2019-12-25 19:01
 *对Student类的改进

 */
public class Student1 {

    int number;//学号
    int state;//年级
    int score;//成绩

    //显示学生的信息
    public String info(){
        return "学号："+number+"，年级："+state+",成绩"+score;
    }

}
class StudentTest1{
    public static void main(String[] args) {
        //创建Student类型的数组
        Student1[] stus = new Student1[20];
        //给数组元素赋值
        for(int i = 0;i<stus.length;i++){
            stus[i] = new Student1();
            //给student对象的属性赋值
            stus[i].number = i +1;
            //年级[1,6]
            stus[i].state = (int)(Math.random()*(6-1+1)+1);
            //成绩[0,100]
            stus[i].score = (int)(Math.random()*(100-0+1)+0);
        }
        //遍历学生数组
        StudentTest1 s1 = new StudentTest1();
        s1.print(stus);
        //打印出三年级state=3学生的信息
        s1.searchState(stus,3);

        System.out.println("接下来使用冒泡排序按学生成绩排序，并遍历所有信息");
        s1.sort(stus);
        s1.print(stus);

        //遍历
       /* for(int i = 0;i<stus.length;i++){
            System.out.println(stus[i].info());
        }*/

    }
    //遍历Student1[]数组的操作(把操作封装到方法里面）
    public void print(Student1[] stus){
        //遍历学生数组
        for(int i = 0;i<stus.length;i++){
            //直接打印会显示地址值。必须得调用
            System.out.println(stus[i].number+","+stus[i].state+","+stus[i].score);
        }
    }

    /**
     * 查找Student1[]指定年级的信息
     * @param stus 要找的数组
     * @param state 要找的年级
     */
    public void searchState(Student1[] stus,int state){
        for(int i = 0;i<stus.length;i++){
            if(stus[i].state == state){
                System.out.println( stus[i].info());
            }
        }
    }
    public void sort(Student1[] stus){//加形参Student1[] stus的原因：如果不加stus会报错
        for(int i = 0;i<stus.length - 1;i++){
            for(int j = 0;j<stus.length - 1- i;j++){
                if(stus[j].score > stus[j+1].score){
                    Student1 temp = stus[j]; //交换的不是学生成绩，是学生
                    stus[j] = stus[j+1];
                    stus[j+1]= temp;
                }
            }
        }
    }
}
```

```java
package com.oop;

/**
 * @author jiajinshuo
 * @create 2019-12-26 11:24
 * 封装数组工具类
 */
public class ArrayUtil {
    //求数组最大值
    public int getMax(int[] arr){
        int arrayMax = arr[0];
        for(int i = 1;i<arr.length;i++){
            if(arr[i] > arrayMax){
                arrayMax = arr[i];
            }
        }
        return arrayMax;
    }
    //求数组最小值
    public int getMin(int[] arr){
        int arraMin = arr[0];
        for(int i = 1;i<arr.length;i++){
            if(arr[i]<arraMin){
                arraMin = arr[i];
            }
        }
        return arraMin;
    }
    //求数组的总和
    public int getSum(int[] arr){
        int arraySum = 0;
        for(int i = 0;i< arr.length;i++){
            arraySum+=arr[i];
        }
        return arraySum;
    }
    //求数组的平均值
    public int getAvg(int[] arr){
        //方法中调用方法，我还愁怎么把局部变量arraySum拿进来
        return (getSum(arr) / arr.length);
    }
    //反转数组
    public void reverse(int[] arr){
        for(int i = 0;i< arr.length / 2;i++){
            int temp = arr[i];
            arr[i]  = arr[arr.length - 1 -i];
            arr[arr.length - i - 1] = temp;

        }

    }
    //数组的复制
    public int[] arrayCopy(int[] arr){
        int[] arr1 = new int[arr.length];
        for(int i = 0;i<arr1.length;i++){
            arr1[i] = arr[i];
        }
        return arr1;
    }
    //元素的查找
    public int getIndex(int[] arr,int dest){
        for(int i = 0;i<arr.length;i++){
            if(dest == arr[i]){
                return i;
            }
        }
        return -1;//返回一个负数表示没有找到

    }
}


package com.oop;

import java.util.Arrays;

/**
 * @author jiajinshuo
 * @create 2019-12-26 11:30
 */
public class ArrayUtilTest {
    public static void main(String[] args) {

        ArrayUtil au = new ArrayUtil();
        int[] arr = {56,-2,88,0,9,89,66};

        System.out.println(au.getMax(arr));
        System.out.println(au.getMin(arr));
        System.out.println(au.getSum(arr));
        System.out.println(au.getAvg(arr));
        au.reverse(arr);
        System.out.println(Arrays.toString(arr));
        int index = au.getIndex(arr, 0);
        if(index>=0){
            System.out.println("找到了，索引为"+index);
        }else {
            System.out.println("没有找到");
        }

    }
}

```

```java
package com.oop;

/**
 * @author jiajinshuo
 * @create 2019-12-26 12:48
 * jdk5开始：可变个数形参。参数是0个或多个
 * 格式：
 * 数据类型...变量名
 * 与本类中，方法名相同，参数不同的方法之间构成重载。
 * 类似数组。把[] 换成...
 */
public class MethodArgs {

    public void show(int i){}
    public void show(int i,int j){}
    public void show(int ... i){

    }
    //public void show(int[] i){}  与方法名相同，形参类型也相同的数组不构成重载

    public static void main(String[] args) {
        MethodArgs ma = new MethodArgs();
        ma.show(1,2,3,7);
        ma.show();

    }
    public void show (int i ,String ... str){}//在参数列表中必须放在末尾
}

```

#### 递归

```java
package com.oop;

/**
 * @author jiajinshuo
 * @create 2019-12-26 18:38
 * 递归
 * 向着已知的方向去递归
 */
public class RecursionTest {
    public static void main(String[] args) {

        RecursionTest rt = new RecursionTest();

        System.out.println(rt.getSum(100));
        System.out.println(rt.jieCheng(10));
        System.out.println(rt.f(10));
        System.out.println(rt.f1(8));

    }
    //计算1-100自然数的和
    public int getSum(int n){
        if(n == 1){
            return 1;
        }else {
            return n + getSum(n - 1);
        }
    }
    //n的阶乘
    public int jieCheng(int n){
        if(n == 1){
            return 1;
        }else {
            return n*jieCheng(n-1);
        }
    }
    //已知有一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),其中n是大于0
    //的整数，求f(10)的值。
    public int f(int n){
        if(n == 0){
            return 1;
        }else if(n == 1){
            return 4;
        }else {
            return 2 * f(n - 1) +f(n - 2);
        }
    }
    //输入一个数据n，计算斐波那契数列(Fibonacci)的第n个值
    //1 1 2 3 5 8 13 21 34 55
    //规律：一个数等于前两个数之和
    //要求：计算斐波那契数列(Fibonacci)的第n个值，并将整个数列打印出来
    public int f1(int n){
        if(n == 1){
            return 1;
        }else if(n == 2){
            return 1;
        }else {
            return f1(n - 1)+f1(n - 2);
        }
    }
}

```

#### 单例模式

```java
单例模式：饿汉模式。天然线程安全
public class Bnak{
	private Bnak(){}
	private static Bnak instance = new Bnak();
	public static Bnak getInstance(){
		return instance;
	}
}

单例模式：懒汉模式
public class Bnak{

	private Bnak(){}
	private static Bnak instance = null;
	public static Bnak getInstance(){
		if(instance == null){
			instance = new Bnak();
		}
		return instance;
	}
}
```

```java
package com.singleton;

/**
 * @author jiajinshuo
 * @create 2020-01-04 16:54
 * 把单例模式（懒汉式）改成线程安全
 */
public class BankTest {
}

class Bank{

    private Bank(){

    }
    private static Bank instance = null;
    public static Bank getInstance(){

        //方式二 ,外边的线程不用等了
        if(instance == null){

            if(instance == null){
                instance = new Bank();
            }
        }
        return instance;



//方式一
//        synchronized (Bank.class) {//效率低，其他线程进来啥也没干，就返回了以前的实例
//            if(instance == null){
//                instance = new Bank();
//            }
//            return instance;
//        }
    }
}
```

#### 代理模式

```java
package com.atguigu.java;

public class StaticProxyTest {

	public static void main(String[] args) {
		Star s = new Proxy(new RealStar());
		s.confer();
		s.signContract();
		s.bookTicket();
		s.sing();
		s.collectMoney();
	}
}

interface Star {
	void confer();// 面谈

	void signContract();// 签合同

	void bookTicket();// 订票

	void sing();// 唱歌

	void collectMoney();// 收钱
}

class RealStar implements Star {

	public void confer() {
	}

	public void signContract() {
	}

	public void bookTicket() {
	}

	public void sing() {
		System.out.println("明星：歌唱~~~");
	}

	public void collectMoney() {
	}
}

class Proxy implements Star {
	private Star real;

	public Proxy(Star real) {
		this.real = real;
	}

	public void confer() {
		System.out.println("经纪人面谈");
	}

	public void signContract() {
		System.out.println("经纪人签合同");
	}

	public void bookTicket() {
		System.out.println("经纪人订票");
	}

	public void sing() {
		real.sing();
	}

	public void collectMoney() {
		System.out.println("经纪人收钱");
	}
}

```

#### 工厂方法模式

```java
package com.atguigu.pattern.factory.method;
interface Car{
void run();
}
//两个实现类
class Audi implements Car{
public void run() {
System.out.println("奥迪在跑");
}
}
class BYD implements Car{
public void run() {
System.out.println("比亚迪在跑");
}
}
//工厂接口
interface Factory{
Car getCar();
}
//两个工厂类
class AudiFactory implements Factory{
public Audi getCar(){
return new Audi();
}
}
class BydFactory implements Factory{
public BYD getCar(){
return new BYD();
}
}
public class Client {
public static void main(String[] args) {
Car a = new AudiFactory().getCar();
Car b = new BydFactory().getCar();
a.run();
b.run();
}
}
```

#### 代理模式

##### 静态代理

```java
package com.qlu;

/**
 * @author jiajinshuo
 * @create 2019-12-19 16:28
 */
//静态代理
    //特点：代理类和被代理类在编译期间就写死了

interface ClothFactory{

    void produceCloth();

}
//代理类
class ProxyClothFactory implements  ClothFactory{

    private ClothFactory clothFactory;


    public ProxyClothFactory(ClothFactory clothFactory) {
        this.clothFactory = clothFactory;
    }

    @Override
    public void produceCloth() {
        System.out.println("代理工厂做准备工作");
        clothFactory.produceCloth();
        System.out.println("代理工厂做收尾工作");
    }
}
//被代理类
 class NikeClothFactory implements ClothFactory {


    @Override
    public void produceCloth() {
        System.out.println("耐克生产一批鞋");
    }
}

public class StaticProxyTest{

    public static void main(String[] args) {
        //需要被代理类对象，通过构造器又得穿一个参数，参数为代理类对象，所以先造代理类对象
        NikeClothFactory nike = new NikeClothFactory();
        //创建代理类对象
        ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nike);
        proxyClothFactory.produceCloth();
    }

}

```

```java
package com.atguigu.java;

public class StaticProxyTest {

	public static void main(String[] args) {
		Star s = new Proxy(new RealStar());
		s.confer();
		s.signContract();
		s.bookTicket();
		s.sing();
		s.collectMoney();
	}
}

interface Star {
	void confer();// 面谈

	void signContract();// 签合同

	void bookTicket();// 订票

	void sing();// 唱歌

	void collectMoney();// 收钱
}
//被代理类
class RealStar implements Star {

	public void confer() {
	}

	public void signContract() {
	}

	public void bookTicket() {
	}

	public void sing() {
		System.out.println("明星：歌唱~~~");
	}

	public void collectMoney() {
	}
}
//代理类
class Proxy implements Star {
	private Star real;

	public Proxy(Star real) {
		this.real = real;
	}

	public void confer() {
		System.out.println("经纪人面谈");
	}

	public void signContract() {
		System.out.println("经纪人签合同");
	}

	public void bookTicket() {
		System.out.println("经纪人订票");
	}

	public void sing() {
		real.sing();
	}

	public void collectMoney() {
		System.out.println("经纪人收钱");
	}
}

```



##### 动态代理

```java
package com.qlu;


import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @author jiajinshuo
 * @create 2019-12-19 16:54
 */
//动态代理
interface Human{

        String getBelief();
        void eat(String food);
}
//被代理类
class SuperMan implements Human{

    @Override
    public String getBelief() {
        return "I believe i can fly";
    }

    @Override
    public void eat(String food) {
        System.out.println("你喜欢吃"+food);
    }
}

class HumanUtils{
    public void method1(){
        System.out.println("通用方法一=====================");
    }
    public void method2(){
        System.out.println("通用方法二=====================");
    }
}

class ProxyFactory{
    //调用此方法返回一个代理类对象
    public static Object getProxyInstance(Object obj){//obj被代理类对象
        MyInvocationHandler handler = new MyInvocationHandler();
        handler.bind(obj);
        //参数1，obj是哪个加载器加载的我和你一样。参数2，代理类和被代理类要实现同样的接口。参数3，InvocationHandler的实例
        return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);

    }
}

class MyInvocationHandler implements InvocationHandler{
    //被代理类的对象
    private Object obj;
    public void bind(Object obj){
        this.obj = obj;
    }
    //当我们通过代理类的对象调用方法a时，就会动态的调用invoke（）。
    // 参数1，代理类对象，参数2，代理类调用的方法 参数3，被代理类同名方法的参数
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        HumanUtils hu = new HumanUtils();
        hu.method1();
        //将被代理类要执行的方法功能声明在invoke（）中。method就是getBelief。当method为eat()时，args就是屎
       Object returnValue =  method.invoke(obj,args);
        hu.method2();
       return returnValue;
    }
}

public class ProxyTest {

    public static void main(String[] args) {
        SuperMan superMan = new SuperMan();
        //proxyInstance的对象
        Human proxyInstance = (Human)ProxyFactory.getProxyInstance(superMan);
        String belief = proxyInstance.getBelief();//动态的调用了被代理类的方法
        System.out.println(belief);
        proxyInstance.eat("屎");
        //当通过代理类的对象调用这两个方法的时候，执行的时候是被代理类同名方法的调用
    }
}

```



#### JDBC

```java
package com.qlu;

import java.sql.*;

/**
 * @author jiajinshuo
 * @create 2020-02-18 21:26
 1,注册驱动
 2，获取连接
 3，获取操作数据库的预处理对象
 4，执行SQL获得结果集
 5，遍历结果集
 6，释放资源
 */
public class Demo1 {
    public static void main(String[] args) {

        Connection conn = null;
        PreparedStatement  ps= null;
        ResultSet rs = null;

        try {
            Class.forName("com.mysql.jdbc.Driver");
            try {
                //DriverManager是一个类，getConnection()为该类的静态方法
                conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/ssm","root", "1227");
                //String sql = "insert into account(name,money) values(?,?)";
                String sql = "select name,money from account where id >?";
                //prepareStatement为Connection接口中的方法
                 ps = conn.prepareStatement(sql);
                ps.setObject(1,2);

                rs = ps.executeQuery();
                while (rs.next()){//游标（指针）移动
                    //取出第一列和第二列
                    System.out.println(rs.getObject(1)+"-----"+rs.getObject(2));
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }finally {

            if(rs!=null){
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if(ps!=null){
                try {
                    ps.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if(conn!=null){
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

```

自己封装JDBC

```JAVA
package com.qlu;

import java.io.IOException;
import java.sql.*;
import java.util.Properties;

/**
 * @author jiajinshuo
 * @create 2020-02-19 15:36
 * 自己封装JDBC
 */
public class JDBCUtil {

    static Properties pros = null;
    //只在类加载的时候执行一次
    static{
        try {
            pros = new Properties();//第一次忘记new，报空指针了
            pros.load(Thread.currentThread().getContextClassLoader().getResourceAsStream("db.properties"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //获得MySQL的连接
    public static Connection getMysqlConnection(){

        try {
            Class.forName(pros.getProperty("mysqlDriver"));
            return DriverManager.getConnection(pros.getProperty("mysqlURL"),
                    pros.getProperty("mysqlUname"), pros.getProperty("mysqlPwd"));
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }

    }
    //获得Oracle的连接
    public static Connection getOracleConnection(){

        try {
            Class.forName(pros.getProperty("oracleDriver"));
            return DriverManager.getConnection(pros.getProperty("oracleURL"),
                    pros.getProperty("oracleUname"), pros.getProperty("oraclePwd"));
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }

    }
    //方法的重载
    public static void close(ResultSet rs, PreparedStatement ps,Connection conn){

        if(rs!=null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if(ps!=null){
            try {
                ps.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if(conn!=null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

    }
    public static void close(PreparedStatement ps,Connection conn){

        if(ps!=null){
            try {
                ps.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if(conn!=null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

    }
}

```

数据库配置文件db.properties

```properties

#JDBC
mysqlDriver=com.mysql.jdbc.Driver
mysqlURL=jdbc:mysql://localhost:3306/ssm
mysqlUname=root
mysqlPwd=1227

#Oracle
oracleDriver=oracle.jdbc.driver.OracleDriver
oracleURL=jdbc:oracle:thin:@localhost:1521:scott
oracleUname=//用户名
oraclePwd=//密码
```

#### Spring

Aop的配置步骤

```xml

    <!-- 配置srping的Ioc,把service对象配置进来-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"></bean>

    <!--spring中基于XML的AOP配置步骤
        1、把通知Bean也交给spring来管理
        2、使用aop:config标签表明开始AOP的配置
        3、使用aop:aspect标签表明配置切面
                id属性：是给切面提供一个唯一标识
                ref属性：是指定通知类bean的Id。
        4、在aop:aspect标签的内部使用对应标签来配置通知的类型
               我们现在示例是让printLog方法在切入点方法执行之前之前：所以是前置通知
               aop:before：表示配置前置通知
                    method属性：用于指定Logger类中哪个方法是前置通知
                    pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强

            切入点表达式的写法：
                关键字：execution(表达式)
                表达式：
                    访问修饰符  返回值  包名.包名.包名...类名.方法名(参数列表)
                标准的表达式写法：
                    public void com.itheima.service.impl.AccountServiceImpl.saveAccount()
                访问修饰符可以省略
                    void com.itheima.service.impl.AccountServiceImpl.saveAccount()
                返回值可以使用通配符，表示任意返回值
                    * com.itheima.service.impl.AccountServiceImpl.saveAccount()
                包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*.
                    * *.*.*.*.AccountServiceImpl.saveAccount())
                包名可以使用..表示当前包及其子包
                    * *..AccountServiceImpl.saveAccount()
                类名和方法名都可以使用*来实现通配
                    * *..*.*()
                参数列表：
                    可以直接写数据类型：
                        基本类型直接写名称           int
                        引用类型写包名.类名的方式   java.lang.String
                    可以使用通配符表示任意类型，但是必须有参数
                    可以使用..表示有无参数均可，有参数可以是任意类型
                全通配写法：
                    * *..*.*(..)

                实际开发中切入点表达式的通常写法：
                    切到业务层实现类下的所有方法
                        * com.itheima.service.impl.*.*(..)
    -->

    <!-- 配置Logger类 -->
    <bean id="logger" class="com.itheima.utils.Logger"></bean>

    <!--配置AOP-->
    <aop:config>
        <!--配置切面 -->
        <aop:aspect id="logAdvice" ref="logger">
            <!-- 配置通知的类型，并且建立通知方法和切入点方法的关联-->
            <aop:before method="printLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"></aop:before>
        </aop:aspect>
    </aop:config>
```

多种通知

```xml
 <aop:config>
        <!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容
              此标签写在aop:aspect标签内部只能当前切面使用。
              它还可以写在aop:aspect外面，此时就变成了所有切面可用
          -->
        <aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"></aop:pointcut>
        <!--配置切面 -->
        <aop:aspect id="logAdvice" ref="logger">
            <!-- 配置前置通知：在切入点方法执行之前执行
            <aop:before method="beforePrintLog" pointcut-ref="pt1" ></aop:before>-->

            <!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个
            <aop:after-returning method="afterReturningPrintLog" pointcut-ref="pt1"></aop:after-returning>-->

            <!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个
            <aop:after-throwing method="afterThrowingPrintLog" pointcut-ref="pt1"></aop:after-throwing>-->

            <!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行
            <aop:after method="afterPrintLog" pointcut-ref="pt1"></aop:after>-->

            <!-- 配置环绕通知 详细的注释请看Logger类中-->
            <aop:around method="aroundPringLog" pointcut-ref="pt1"></aop:around>
        </aop:aspect>
    </aop:config>
```

##### 使用Aop使用xml配置事务

```xml
 <!-- spring中基于XML的声明式事务控制配置步骤
        1、配置事务管理器
        2、配置事务的通知
                此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的
                使用tx:advice标签配置事务通知
                    属性：
                        id：给事务通知起一个唯一标识
                        transaction-manager：给事务通知提供一个事务管理器引用
        3、配置AOP中的通用切入点表达式
        4、建立事务通知和切入点表达式的对应关系
        5、配置事务的属性
               是在事务的通知tx:advice标签的内部

     -->
    <!-- 配置事务管理器 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <!-- 配置事务的通知-->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <!-- 配置事务的属性
                isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。
                propagation(传播)：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。
                read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。
                timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。
                rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。
                no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。
        -->
        <tx:attributes>
            <tx:method name="*" propagation="REQUIRED" read-only="false"/>
            //业务层接口的方法
            <tx:method name="find*" propagation="SUPPORTS" read-only="true"></tx:method>
        </tx:attributes>
    </tx:advice>

    <!-- 配置aop-->
    <aop:config>
        <!-- 配置切入点表达式-->
        <aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"></aop:pointcut>
        <!--建立切入点表达式和事务通知的对应关系 -->
        <aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"></aop:advisor>
    </aop:config>
```

##### 基于注解实现事务

```xml
    <!-- spring中基于注解 的声明式事务控制配置步骤
        1、配置事务管理器
        2、开启spring对注解事务的支持
        3、在需要事务支持的地方使用@Transactional注解
     -->
    <!-- 配置事务管理器 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>


    <!-- 开启spring对注解事务的支持-->
    <tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>
```



#### Mybatis

一对多

一个人对应多个账户

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.qlu.dao.UserDao">
    <!--一对一-->
    <!--定义封装user的resultmap-->
    <resultMap id="userMap" type="com.qlu.domain.User">
        <id property="id" column="id"></id>
        <result property="username" column="username"></result>
        <result property="address" column="address"></result>
        <result property="sex" column="sex"></result>
        <result property="birthday" column="birthday"></result>
        <!--配置user中的accounts集合映射-->
       <collection property="accounts" ofType="com.qlu.domain.Account1">
           <id property="id" column="aid"></id>
           <result property="uid" column="uid"></result>
           <result property="money" column="money"></result>
       </collection>
    </resultMap>


    <select id="find" resultMap="userMap">
       select * from user u left outer join account1 a  on a.uid = u.id
    </select>


</mapper>

```

一对一

每个账户对应一个人



```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.qlu.dao.Account1Dao">

    <!--定义封装user和account1的resultmap-->
    <resultMap id="useraccount1" type="com.qlu.domain.Account1">
        <id property="id" column="aid"></id>
        <result property="uid" column="uid"></result>
        <result property="money" column="money"></result>
        <!--一对一关系映射-->
        <association property="user" column="uid" javaType="com.qlu.domain.User">
            <id property="id" column="id"/>
            <result property="username" column="username"/>
            <result property="address" column="address"/>
            <result property="sex" column="sex"/>
            <result property="birthday" column="birthday"/>
        </association>
    </resultMap>

    <select id="findAccount1" resultMap="useraccount1">
        select u.*,a.id as aid,a.uid,a.money from account1 a,user u where u.id = a.uid
    </select>

</mapper>

```

